/* Generated by re2c */
// Copyright 2011 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "lexer.h"

#include <stdio.h>

#include "eval_env.h"
#include "util.h"

using namespace std;

bool Lexer::Error(const string& message, string* err) {
//   // Compute line/column.
//   int line = 1;
//   const char* line_start = input_.str_;
//   for (const char* p = input_.str_; p < last_token_; ++p) {
//     if (*p == '\n') {
//       ++line;
//       line_start = p + 1;
//     }
//   }
//   int col = last_token_ ? (int)(last_token_ - line_start) : 0;

//   char buf[1024];
//   snprintf(buf, sizeof(buf), "%s:%d: ", filename_.AsString().c_str(), line);
//   *err = buf;
//   *err += message + "\n";

//   // Add some context to the message.
//   const int kTruncateColumn = 72;
//   if (col > 0 && col < kTruncateColumn) {
//     int len;
//     bool truncated = true;
//     for (len = 0; len < kTruncateColumn; ++len) {
//       if (line_start[len] == 0 || line_start[len] == '\n') {
//         truncated = false;
//         break;
//       }
//     }
//     *err += string(line_start, len);
//     if (truncated)
//       *err += "...";
//     *err += "\n";
//     *err += string(col, ' ');
//     *err += "^ near here";
//   }

//   return false;
}

Lexer::Lexer(const char* input) {
  Start("input", input);
}

void Lexer::Start(StringPiece filename, StringPiece input) {
  filename_ = filename;
  input_ = input;
  ofs_ = input_.str_;
  last_token_ = NULL;
}

const char* Lexer::TokenName(Token t) {
  switch (t) {
  case ERROR:    return "lexing error";
  case BUILD:    return "'build'";
  case COLON:    return "':'";
  case DEFAULT:  return "'default'";
  case EQUALS:   return "'='";
  case IDENT:    return "identifier";
  case INCLUDE:  return "'include'";
  case INDENT:   return "indent";
  case NEWLINE:  return "newline";
  case PIPE2:    return "'||'";
  case PIPE:     return "'|'";
  case PIPEAT:   return "'|@'";
  case POOL:     return "'pool'";
  case RULE:     return "'rule'";
  case SUBNINJA: return "'subninja'";
  case TEOF:     return "eof";
  }
  return NULL;  // not reached
}

const char* Lexer::TokenErrorHint(Token expected) {
  switch (expected) {
  case COLON:
    return " ($ also escapes ':')";
  default:
    return "";
  }
}

string Lexer::DescribeLastError() {
  if (last_token_) {
    switch (last_token_[0]) {
    case '\t':
      return "tabs are not allowed, use spaces";
    }
  }
  return "lexing error";
}

void Lexer::UnreadToken() {
  ofs_ = last_token_;
}